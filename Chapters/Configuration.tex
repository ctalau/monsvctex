\chapter{Configuration} % Titlul capotilului
\label{Capitolul3}

The applications in the TDAQ system up to several thousands of objects that represent information to be monitored. For different objects we may have different requirements on the publishing parameters such as the publishing frequency and or the target Information Sharing (IS) server \citep{kolosinformation}.

As an example, the histogram of event data size for the events that were accepted by the event filter needs to be published every second to an IS server called “DF”. For another example, the number of failed checksums for the event data read from the detector should be written to a file called "L1.root" at the end of the running period.

The user of an application should be able to specify these parameters way. We call this specification configuration. In this section we explore how to make this specification expressive,  succinct and simple to use.

\section*{Functionality}

The library should allow the user to specify one or more publishing targets. The publishing targets currently include IS servers, OH servers, files in ROOT \citep{brun1997root} format and standard output. For each target, the user should be able to specify some publishing parameters, for example, the name of the IS server and the publishing interval for an IS publishing target.

Another required functionality is to be able to modify the configuration at runtime. For example, if an operator notices some abnormal conditions in the running of the system, she may enable some debug monitoring information to be published in order to identify and fix the problem. 

\section*{Challenges}

As with other parts of the library, the main challenge of the configuration is the scale of the system. We discuss below how each dimension of scaling impacts the design of the library.

\subsection*{The code size}

First of all, in order to publish a monitored object, the library needs to know the publishing parameters. The first choice is whether to associate the parameters with the objects programmatically (in the source code), or in an external file which is loaded at runtime. We chose the second approach since, any change in the source code requires a recompilation and to create a binary patch of the current release version of the software. The duration and complexity of this process would discourage developers from changing configurations. In the external file approach, a change in configuration can be as simple as editing a text file and checking it in in the source repository.

\subsection*{The number of monitored objects}

With over 5000 monitored objects, we need to keep the configuration file of an application within a manageable size. We leverage the fact that the objects fall into a few semantic categories that share publishing requirements. We define groups of objects that share the same publishing parameters by using regular expressions. 

\begin{figure}[ht]
\centering
\includegraphics[scale=0.6]{Images/oks_regex.png}
\caption{The two approaches for associating publishing parameters with monitored objects: explicit (left) and implicit by using regular expressions (right).}
\label{fig:oks_regex}
\end{figure}

As presented in the figure \ref{fig:oks_regex}, instead of having links from the monitored objects to sets of parameters, we create links from parameters to objects by using configuration rules. A configuration rule is composed of a regular expression and a set of parameters. It is this rules that we store in the configuration file. A nice side-effect of this approach is that if the programmer registers a new object which uses an existing parameter set, she just has to give it a name that matches the regular expression.

One problem related to the object sets specification as regular expressions is that it is not easy to express exceptions from a rule. For example: we want to publish histograms with names matching {\tt “DEBUG/.*”} every 10 seconds, but we have a really big histogram among them that we would like to publish less often. To this end, we chose to add an exclude filter to every configuration rule that specifies the exceptions to that rule.

\subsection*{The number of developers}

In order to avoid complicated link time dependencies between packages, we adopted the split responsibility model: the developer of a library registers some objects and the developer of the application is the one who needs to configure their publishing parameters. Since some objects are registered by one developer and configured by another one, a clear convention should be used between the two. 
Our configuration mechanism allows the developer of the library to provide configuration rules for the objects registered in that library. To this end we created the concept of rule bundle which contains configuration rules and links other rule bundles. With this approach the developer of the main application can just link the rule bundle of the library in the rule bundle of the application. This mechanism handles nicely transitive dependencies by using transitively linked bundles.

The configuration files are a set of interlinked XML files, one per application or library. These files form the configuration database which can be loaded at runtime with the OKS system. The database is an object oriented one, where for example every application is described by a {\tt PublishingApplication} object which has a one to one relation to a rule bundle which is represented by an object of class {\tt ConfigurationRuleBundle}. The complete schema of the configuration database is presented in figure \ref{fig:oks_schema}. 

\begin{figure}[ht]
\centering
\includegraphics[scale=0.75]{Images/oks_schema.png}
\caption{Configuration database schema.}
\label{fig:oks_schema}
\end{figure}

\subsection*{The number of application instances}

Some applications in our system have several thousands of instances which use similar configuration files. However some of the configuration parameters differ, for example, if every application writes the objects in a file, then the name of the file should be different for the applications running on the same node. These configuration files are generated from a common template using the partition editor tool.

Another challenge is related to the runtime configuration modifications. The operators are allowed to replace an existing rule by specifying its name and the new rule. Usually the same configuration change should be applied to many instances of the application, so we created a tool that applies a configuration change to a subset of the applications specified by a regular expression.
