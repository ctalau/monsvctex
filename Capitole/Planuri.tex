% Chapter 7

\chapter{Planuri de dezvoltare ulterioar\u a}
\label{Capitolul7}

\^ In urma realiz\u arii acestui proiect apar mai multe posibile direc\c tii de dezvoltare ulterioara:
\begin{description}
\item [ Tipuri monadice ] \^ In ceea ce prive\c ste extensia System \fhat cu tipuri monadice (sectiunea \ref{tip_monad}), desi Turing completa, multe programe sunt complicat de exprimat. Un exemplu bun \^ in acest sens este chiar codificarea construc\c tiei \emph{case} (demonstra\c tia \ref{proof_ntcompl}). O variant\u a pentru aceast\u a problem\u a ar fi relaxarea regulilor de tip. \^ In formularea actual\u a, doar {\scriptsize (MT-APP),(MT-SUB)} \c si {\scriptsize (MT-LETREC)} sunt aplicabile pentru tipuri din \textbf{NT}.

    O alt\u a solu\c tie este adaugarea unor construc\c tii sintactice mai simple decat \textbf{bind} si \textbf{unit} o alternativ\u a viabil\u a ar fi construc\c tia \textbf{do} din Haskell.

\item [ Optimiz\u ari ] Un alt aspect care ar putea fi imbun\u at\u a\c tit este viteza de execu\c tie a programelor scrise in System \fhat. Cel mai mare beneficiu ar  fi adus de folosirea unor implement\u ari de nivel sc\u azut (direct \^ in Java) pentru tipuri de date standard precum \textbf{Int} sau \textbf{String} \c si pentru func\c tiile care opereaz\u a pe aceastea. Pentru a \^ incadra totu\c si \^ in cadrul teoretic studiat aceste implementari putem vedea de exemplu tipul \textbf{Nat} ca av\^ and umr\u atoarea declara\c tie
    $$ Datatype \quad \textbf{Nat} := 0 : \textbf{Nat}^{\hat{\iota}} \:|\: 1 : \textbf{Nat}^{\hat{\iota}} \:| \: \dots $$

\item [ Tipuri coinductive ] Datorit\u a propriet\u a\c tii de normalizare puternic\u a \c si a confluen\c tei, am putut folosi o strategie de evaluare \emph{call-by-value}. Pentru implementarea extensiei System \fhat cu tipuri de date coinductive, ar trebui folosit\u a o strategie de evaluare lene\c s\u a.

\item [ Mai pu\c tine adnot\u ari ]  Un inconvenient al System \fhat este c\u a, necesit\u a adnot\u ari excesive cu tipuri (chiar dac\u a adnot\u arile cu dimensiuni sunt deduse). O posibil\u a solu\c tie ar fi folosirea unui sistem de tipuri Hindley-Milner care s\u a deduc\u a tipuri care apar\c tin System \frec pentru termeni, iar apoi pe baza acestor tipuri deduse sa se foloseasca System \fhat. \^ In func\c tie de setul de constante ales, se poate pierde proprietatea de normalizare puternic\u a : cazul operatorului \emph{fix : $(X \to X) \to X$}, sau se poate diminua expresivitatea limbajului : de exemplu, \^ in HM nu pot fi exprimate numerele naturale \^ in codificare Church. A\c sadar trebuie f\u acut un compromis \^ intre expresivitate \c si cantitatea de adnot\u ari de tip.
\end{description}
